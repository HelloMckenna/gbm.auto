gbm.map <- function(x,        #vector of longitudes, from make.grid in mapplots; grids[,gridslon]
                    y,        #vector of latitudes, from make.grid in mapplots; grids[,gridslat]
                    z,        #vector of abundances generated by gbm.predict.grids, from make.grid in mapplots; grids[,predabund]
                    byx = NULL,      #longitudinal width of grid cell, from make.grid in mapplots. Autogenerated if left blank.
                    byy = NULL,      #latitudinal height of grid cell, from make.grid in mapplots. Autogenerated if left blank.
                    grdfun = mean,   #make.grid operand for >=2 values per cell. Default:mean
                    mapmain = "Predicted abundance: ",  #output map image response variable title, from basemap in mapplots
                    species,  #Response variable name, from basemap in mapplots; names(samples[i])
                    heatcol,  #abundance colour scale, defaults to heatcol from mapplots, from legend.grid & draw.grid in mapplots
                    shape = coast, #basemap shape to draw, from draw.shape in mapplots. Defaults: 'coast': UK & Ire
                    landcol = "darkgreen", #colour for 'null' area of map, if appropriate, from draw.shape in mapplots
                    mapback, #basemap background, defaults to "lightblue", from basemap
                    legendloc = "bottomright", #location on map of legend box, from legend.grid in mapplots
                    legendtitle, #the metric of abundance, e.g. CPUE for fisheries, from legend.grid in mapplots
                    inset, #from legend.grid in mapplots
                    bg = "white",  #backgroud colour of legend, from legend.grid in mapplots
                    grids,  #used by byx/byy generator, makes grids object created by gbm.auto available to gbm.map
                    gridslon, #ditto
                    gridslat, #ditto
                    predabund) #ditto #required?!

# Generalised Boosting Models, automated map generator. Simon Dedman, 2014, simondedman@gmail.com, https://github.com/SimonDedman/gbm.auto

# Generates maps from the outputs of gbm.step then gbm.predict.grids, handled automatically within gbm.auto but can be run alone, and
# generates representativeness surfaces from the output of gbm.rsb (suggest: z = rsbdf[,"Unrepresentativeness"],
# mapmain = "Unrepresentativeness: ",legendtitle = "UnRep 0-1"). Suggested code for outputting to e.g. png:
# png(...); par(...); gbm.map(...); dev.off()
{
  require(mapplots)
  library(mapplots)
  # get Britain & Ireland coast data. I'm looking to make this global but am having a problem w/ the maps packge
  data(coast)
  # if users hasn't entered byx or byy values, generate them from the data
  if(is.null(byx)) {
    # work out cell size for uniform square gridded data: Create blank vector for grid length calcs
    bydist<-rep(NA,length(grids[,gridslon]))
    # and attach it to grids
    grids<-cbind(grids,bydist)
    # fill it: if [next longitude minus current longitude] equals [current longitude minus previous longitude], that's a uniform cell.
    # data rounded to prevent tiny fluctuations counting as differences. Need to set that tolerance.
    # Could do 10% of average distance between uniform points, but you don't know that til the end!
    grids[2:(length(grids[,gridslon])-1),"bydist"] <-
      ifelse(round(grids[2:(length(grids[,gridslon])-1),"LONGITUDE"]-grids[1:(length(grids[,gridslon])-2),"LONGITUDE"],digits=5)
         ==
         round(grids[3:length(grids[,gridslon]),"LONGITUDE"]-grids[2:(length(grids[,gridslon])-1),"LONGITUDE"],digits=5),
         round(grids[2:(length(grids[,gridslon])-1),"LONGITUDE"]-grids[1:(length(grids[,gridslon])-2),"LONGITUDE"],digits=5),NA)
    # Take an average of those distances, they should all be identical anyway. Apply it to byx & byy.
    byx<-mean(grids$bydist,na.rm=TRUE)
    byy<-byx
  }
  grd <- make.grid(x, y, z, byx, byy, xlim=range(x), ylim=range(y),fun=grdfun) #create gridded data. fun defaults to sum which is bad
  breaks <- breaks.grid(grd,zero=TRUE,quantile=1) # define breakpoints from grd, allow 0 category, max=max Z from grd
  basemap(xlim=range(x), ylim=range(y), main=paste(mapmain,species,sep=""), bg=mapback)
  draw.grid(grd,breaks,col=heatcol) # plot grd data w/ breaks for colour breakpoints
  draw.shape(shape, col=landcol) # add coastline
  legend.grid(legendloc, breaks=breaks, type=2, inset=0, bg="white", title=legendtitle, col=heatcol) #breaks=breaks/1000 was causing odd legend? From make.grid help, Hans using to convert kg to t?
}