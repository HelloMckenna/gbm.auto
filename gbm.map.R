gbm.map <- function(x,        # vector of longitudes, from make.grid in mapplots; grids[,gridslon]
                    y,        # vector of latitudes, from make.grid in mapplots; grids[,gridslat]
                    z,        # vector of abundances generated by gbm.predict.grids, from make.grid in mapplots; grids[,predabund]
                    byx = NULL,      # longitudinal width of grid cell, from make.grid in mapplots. Autogenerated if left blank.
                    byy = NULL,      # latitudinal height of grid cell, from make.grid in mapplots. Autogenerated if left blank.
                    mapmain = "Predicted abundance: ",  # output map image response variable title, from basemap in mapplots
                    species,  # Response variable name, from basemap in mapplots; names(samples[i])
                    heatcol,  # abundance colour scale, defaults to heatcol from mapplots, from legend.grid & draw.grid in mapplots
                    shape = coast, # basemap shape to draw, from draw.shape in mapplots
                    landcol = "darkgreen",  # colour for 'null' area of map, if appropriate, from draw.shape in mapplots
                    legendloc = "bottomright", # location on map of legend box, from legend.grid in mapplots
                    legendtitle, # the metric of abundance, e.g. CPUE for fisheries, from legend.grid in mapplots
                    inset, # from legend.grid in mapplots
                    bg = "white",  # backgroud colour or active area, from legend.grid in mapplots
                    grids,  # used by byx/byy generator, makes grids object created by gbm.auto available to gbm.map
                    gridslon, #ditto
                    gridslat, #ditto
                    predabund) #ditto

# Generalised Boosting Models, automated map generator. Simon Dedman, 2014, simondedman@gmail.com, https://github.com/SimonDedman/gbm.auto

# Generates maps from the outputs of gbm.step then gbm.predict.grids, handled automatically within gbm.auto but can be run alone, and
# generates representativeness surfaces from the output of gbm.rsb (suggest: z = rsbdf[,"Unrepresentativeness"],
# mapmain = "Unrepresentativeness: ",legendtitle = "UnRep 0-1"). Suggested code for outputting to e.g. png:
# png(...); par(...); gbm.map(...); dev.off()
{
  require(mapplots)
  library(mapplots)
  # get Britain & Ireland coast data. I'm looking to make this global but am having a problem w/ the maps packge
  data(coast)
  # if users hasn't entered byx or byy values, generate them from the data
  if(is.null(byx)) {
    # work out cell size for uniform square gridded data: Create blank vector for grid length calcs
    bydist<-rep(NA,length(grids[,gridslon]))
    # and attach it to grids
    grids<-cbind(grids,bydist)
    # fill it: if [next longitude minus current longitude] equals [current longitude minus previous longitude], that's a uniform cell.
    # data rounded to prevent tiny fluctuations counting as differences. Need to set that tolerance.
    # Could do 10% of average distance between uniform points, but you don't know that til the end!
    grids[2:(length(grids[,gridslon])-1),"bydist"] <-
      ifelse(round(grids[2:(length(grids[,gridslon])-1),"LONGITUDE"]-grids[1:(length(grids[,gridslon])-2),"LONGITUDE"],digits=5)
         ==
         round(grids[3:length(grids[,gridslon]),"LONGITUDE"]-grids[2:(length(grids[,gridslon])-1),"LONGITUDE"],digits=5),
         round(grids[2:(length(grids[,gridslon])-1),"LONGITUDE"]-grids[1:(length(grids[,gridslon])-2),"LONGITUDE"],digits=5),NA)
    # Take an average of those distances, they should all be identical anyway. Apply it to byx & byy.
    byx<-mean(grids$bydist,na.rm=TRUE)
    byy<-byx
  }
  grd <- make.grid(x, y, z, byx, byy, xlim=range(x), ylim=range(y))
  breaks <- breaks.grid(grd,zero=FALSE)
  basemap(xlim=range(x), ylim=range(y), main=paste(mapmain,species,sep=""))
  draw.grid(grd,breaks,col=heatcol)
  draw.shape(shape, col=landcol)
  legend.grid(legendloc, breaks=breaks/1000, type=2, inset=0, bg="white", title=legendtitle, col=heatcol)
}